<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BlockSuite Editor - Sample</title>
    
    
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        :root {
            --primary-color: #e94560;
            --bg-dark: #1a1a2e;
            --bg-darker: #16213e;
            --text-light: #eee;
            --success-color: #10b981;
            --error-color: #ef4444;
        }
        
        body {
            font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-dark);
            color: var(--text-light);
            min-height: 100vh;
        }
        
        .app-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }
        
        /* Header */
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px 24px;
            background: linear-gradient(135deg, var(--bg-darker) 0%, var(--bg-dark) 100%);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }
        
        .header h1 {
            font-size: 20px;
            font-weight: 600;
            background: linear-gradient(90deg, var(--primary-color), #0f3460);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .header-actions {
            display: flex;
            gap: 12px;
            align-items: center;
        }
        
        /* Controls */
        .controls {
            display: flex;
            gap: 16px;
            padding: 16px 24px;
            background: rgba(255, 255, 255, 0.03);
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            flex-wrap: wrap;
            align-items: center;
        }
        
        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .control-group label {
            font-size: 13px;
            color: rgba(255, 255, 255, 0.7);
        }
        
        input[type="text"] {
            padding: 10px 14px;
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 8px;
            color: var(--text-light);
            font-size: 14px;
            min-width: 280px;
            transition: all 0.2s ease;
        }
        
        input[type="text"]:focus {
            outline: none;
            border-color: var(--primary-color);
            background: rgba(255, 255, 255, 0.1);
        }
        
        input[type="text"]::placeholder {
            color: rgba(255, 255, 255, 0.4);
        }
        
        /* Buttons */
        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, var(--primary-color) 0%, #c23a51 100%);
            color: #fff;
            box-shadow: 0 4px 15px rgba(233, 69, 96, 0.4);
        }
        
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(233, 69, 96, 0.5);
        }
        
        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-light);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.15);
        }
        
        .btn-success {
            background: linear-gradient(135deg, var(--success-color) 0%, #059669 100%);
            color: #fff;
            box-shadow: 0 4px 15px rgba(16, 185, 129, 0.4);
        }
        
        .btn-success:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(16, 185, 129, 0.5);
        }
        
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
            box-shadow: none !important;
        }
        
        /* Editor Container */
        .editor-wrapper {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative;
        }
        
        .editor-container {
            flex: 1;
            background: #fafafa;
            overflow: auto;
            padding: 0;
        }
        
        .simple-editor {
            width: 100%;
            height: 100%;
            min-height: 400px;
            padding: 40px 60px;
            border: none;
            outline: none;
            font-family: 'Georgia', serif;
            font-size: 18px;
            line-height: 1.8;
            resize: none;
            background: #fff;
            color: #333;
        }
        
        .simple-editor:focus {
            outline: none;
        }
        
        .simple-editor::placeholder {
            color: #aaa;
        }
        
        /* Status Bar */
        .status-bar {
            padding: 10px 24px;
            background: var(--bg-darker);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 12px;
            color: rgba(255, 255, 255, 0.6);
            display: flex;
            justify-content: space-between;
        }
        
        .status-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #666;
        }
        
        .status-dot.connected {
            background: var(--success-color);
            box-shadow: 0 0 8px rgba(16, 185, 129, 0.6);
        }
        
        .status-dot.error {
            background: var(--error-color);
            box-shadow: 0 0 8px rgba(239, 68, 68, 0.6);
        }
        
        /* Toast Notifications */
        .toast-container {
            position: fixed;
            bottom: 80px;
            right: 24px;
            z-index: 10000;
        }
        
        .toast {
            padding: 16px 24px;
            border-radius: 8px;
            font-weight: 500;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            animation: slideIn 0.3s ease;
            margin-top: 8px;
        }
        
        .toast.success {
            background: linear-gradient(135deg, var(--success-color) 0%, #059669 100%);
            color: white;
        }
        
        .toast.error {
            background: linear-gradient(135deg, var(--error-color) 0%, #dc2626 100%);
            color: white;
        }
        
        @keyframes slideIn {
            from {
                transform: translateX(100px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        
        /* Loading State */
        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(26, 26, 46, 0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }
        
        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(255, 255, 255, 0.1);
            border-top-color: var(--primary-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        /* Preview Panel */
        .editor-split {
            display: flex;
            gap: 0;
            flex: 1;
            overflow: hidden;
        }
        
        .editor-pane {
            flex: 1;
            min-width: 0;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .editor-pane .editor-container {
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        
        .editor-pane .simple-editor {
            flex: 1;
            min-height: 0;
        }
        
        .preview-pane {
            flex: 1;
            min-width: 0;
            background: rgba(255, 255, 255, 0.02);
            border-left: 1px solid rgba(255, 255, 255, 0.1);
            overflow-y: auto;
            padding: 24px;
        }
        
        .preview-pane.hidden {
            display: none;
        }
        
        .preview-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
            padding-bottom: 12px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .preview-header h3 {
            font-size: 14px;
            color: rgba(255, 255, 255, 0.7);
            font-weight: 500;
        }
        
        .preview-content {
            color: var(--text-light);
            line-height: 1.8;
        }
        
        .preview-content h1 {
            font-size: 28px;
            font-weight: 700;
            margin-bottom: 16px;
            color: var(--primary-color);
        }
        
        .preview-content h2 {
            font-size: 22px;
            font-weight: 600;
            margin: 20px 0 12px;
        }
        
        .preview-content h3 {
            font-size: 18px;
            font-weight: 600;
            margin: 16px 0 10px;
        }
        
        .preview-content p {
            margin-bottom: 12px;
        }
        
        .preview-content .block-divider {
            border: none;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
            margin: 20px 0;
        }
        
        .preview-content .block-todo {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 8px;
        }
        
        .preview-content .block-todo input {
            width: 18px;
            height: 18px;
            accent-color: var(--primary-color);
        }
        
        .preview-content .block-todo.checked span {
            text-decoration: line-through;
            opacity: 0.6;
        }
        
        .preview-content .block-list {
            margin-left: 24px;
            margin-bottom: 8px;
        }
        
        .preview-content .block-quote {
            border-left: 4px solid var(--primary-color);
            padding-left: 16px;
            margin: 16px 0;
            color: rgba(255, 255, 255, 0.7);
            font-style: italic;
        }
        
        .preview-content .block-image {
            margin: 16px 0;
            border-radius: 8px;
            overflow: hidden;
            background: rgba(255, 255, 255, 0.05);
        }
        
        .preview-content .block-image img {
            max-width: 100%;
            height: auto;
            display: block;
        }
        
        .preview-content .block-image.loading {
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100px;
            color: rgba(255, 255, 255, 0.5);
        }
        
        .preview-content .block-image.error {
            border: 1px dashed var(--error-color);
            padding: 16px;
            text-align: center;
            color: var(--error-color);
        }
        
        .preview-content .block-image .image-caption {
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.2);
            font-size: 12px;
            color: rgba(255, 255, 255, 0.6);
        }
        
        .preview-content .block-video {
            margin: 16px 0;
            border-radius: 8px;
            overflow: hidden;
            background: rgba(255, 255, 255, 0.05);
        }
        
        .preview-content .block-video video {
            max-width: 100%;
            display: block;
        }
        
        .preview-content .block-attachment {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 16px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            margin: 12px 0;
            text-decoration: none;
            color: var(--text-light);
            transition: background 0.2s;
        }
        
        .preview-content .block-attachment:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        
        .preview-content .block-attachment .file-icon {
            font-size: 24px;
        }
        
        .preview-content .block-attachment .file-info {
            flex: 1;
        }
        
        .preview-content .block-attachment .file-name {
            font-weight: 500;
        }
        
        .preview-content .block-attachment .file-size {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.5);
        }
        
        .toggle-preview {
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: var(--text-light);
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            display: flex;
            align-items: center;
            gap: 6px;
            transition: all 0.2s;
        }
        
        .toggle-preview:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        
        .toggle-preview.active {
            background: var(--primary-color);
            border-color: var(--primary-color);
        }
        
        .hidden {
            display: none !important;
        }
        
        /* Danger Button */
        .btn-danger {
            background: linear-gradient(135deg, var(--error-color) 0%, #dc2626 100%);
            color: #fff;
            box-shadow: 0 4px 15px rgba(239, 68, 68, 0.4);
        }
        
        .btn-danger:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(239, 68, 68, 0.5);
        }
        
        .btn-info {
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
            color: #fff;
            box-shadow: 0 4px 15px rgba(59, 130, 246, 0.4);
        }
        
        .btn-info:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(59, 130, 246, 0.5);
        }
        
        /* Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        
        .modal {
            background: var(--bg-darker);
            border-radius: 16px;
            padding: 24px;
            min-width: 400px;
            max-width: 600px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 16px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .modal-header h2 {
            font-size: 18px;
            font-weight: 600;
            color: var(--text-light);
        }
        
        .modal-close {
            background: none;
            border: none;
            color: rgba(255, 255, 255, 0.6);
            font-size: 24px;
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }
        
        .modal-close:hover {
            color: var(--text-light);
        }
        
        .modal-body {
            color: var(--text-light);
        }
        
        .info-grid {
            display: grid;
            grid-template-columns: 140px 1fr;
            gap: 12px 16px;
        }
        
        .info-label {
            color: rgba(255, 255, 255, 0.6);
            font-size: 13px;
        }
        
        .info-value {
            font-family: 'SF Mono', Consolas, monospace;
            font-size: 13px;
            word-break: break-all;
            background: rgba(255, 255, 255, 0.05);
            padding: 6px 10px;
            border-radius: 6px;
        }
        
        .modal-footer {
            margin-top: 24px;
            padding-top: 16px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            justify-content: flex-end;
            gap: 12px;
        }
        
        /* API Test Panel */
        .api-panel {
            background: rgba(255, 255, 255, 0.03);
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            padding: 12px 24px;
        }
        
        .api-panel-title {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.5);
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .api-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .btn-sm {
            padding: 8px 14px;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div class="app-container">
        <header class="header">
            <h1>BlockSuite Editor Sample</h1>
            <div class="header-actions">
                <button class="btn btn-success" id="saveBtn" disabled>
                    <span>üíæ</span> Save to Server
                </button>
            </div>
        </header>
        
        <div class="controls">
            <div class="control-group">
                <label for="cardIdInput">Card ID:</label>
                <input type="text" id="cardIdInput" placeholder="Enter card ID to load/save document">
            </div>
            <div class="control-group">
                <label for="apiBaseInput">API Base URL:</label>
                <input type="text" id="apiBaseInput" placeholder="e.g., /plugins/focalboard/api/v2" value="/plugins/focalboard/api/v2">
            </div>
            <button class="btn btn-secondary" id="newDocBtn">
                <span>üìÑ</span> New Document
            </button>
        </div>
        
        <!-- Smart Load Panel -->
        <div class="api-panel" style="background: rgba(233, 69, 96, 0.1); border-left: 3px solid var(--primary-color);">
            <div class="api-panel-title">üöÄ Smart Load (ÌîåÎ°úÏö∞ ÌÖåÏä§Ìä∏)</div>
            <div class="api-buttons">
                <button class="btn btn-primary btn-sm" id="smartLoadBtn">
                    <span>üîÑ</span> Smart Load (Î¨∏ÏÑú ÏûàÏúºÎ©¥ Î°úÎìú, ÏóÜÏúºÎ©¥ Î∏îÎ°ù Î≥ÄÌôò)
                </button>
            </div>
            <div id="flowLog" style="margin-top: 12px; font-size: 12px; color: rgba(255,255,255,0.7); font-family: monospace; white-space: pre-wrap; max-height: 150px; overflow-y: auto;"></div>
        </div>
        
        <!-- API Test Panel -->
        <div class="api-panel">
            <div class="api-panel-title">üîå API Test (4 Endpoints)</div>
            <div class="api-buttons">
                <button class="btn btn-secondary btn-sm" id="loadBtn">
                    <span>üì•</span> GET /content
                </button>
                <button class="btn btn-success btn-sm" id="saveBtn2">
                    <span>üíæ</span> PUT /content
                </button>
                <button class="btn btn-info btn-sm" id="infoBtn">
                    <span>‚ÑπÔ∏è</span> GET /info
                </button>
                <button class="btn btn-danger btn-sm" id="deleteBtn">
                    <span>üóëÔ∏è</span> DELETE
                </button>
                <button class="toggle-preview" id="togglePreviewBtn">
                    <span>üëÅÔ∏è</span> Preview
                </button>
            </div>
        </div>
        
        <div class="editor-wrapper">
            <div class="editor-split">
                <div class="editor-pane">
                    <div class="editor-container" id="editorContainer">
                        <textarea 
                            class="simple-editor" 
                            id="editor" 
                            placeholder="Start typing here...

This is a simple editor for testing the BlockSuite API endpoints.
The content will be saved as Yjs binary data to the server."
                        ></textarea>
                    </div>
                </div>
                <div class="preview-pane hidden" id="previewPane">
                    <div class="preview-header">
                        <h3>üìñ Preview</h3>
                    </div>
                    <div class="preview-content" id="previewContent">
                        <!-- Preview content will be rendered here -->
                    </div>
                </div>
            </div>
            <div class="loading-overlay hidden" id="loadingOverlay">
                <div class="spinner"></div>
            </div>
        </div>
        
        <div class="status-bar">
            <div class="status-indicator">
                <div class="status-dot" id="statusDot"></div>
                <span id="statusText">Ready</span>
            </div>
            <div id="docInfo">No document loaded</div>
        </div>
    </div>
    
    <div class="toast-container" id="toastContainer"></div>
    
    <!-- Info Modal -->
    <div class="modal-overlay hidden" id="infoModal">
        <div class="modal">
            <div class="modal-header">
                <h2>üìã Document Info</h2>
                <button class="modal-close" id="closeInfoModal">&times;</button>
            </div>
            <div class="modal-body">
                <div class="info-grid" id="infoGrid">
                    <!-- Info will be populated here -->
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" id="closeInfoModalBtn">Close</button>
            </div>
        </div>
    </div>
    
    <!-- Delete Confirm Modal -->
    <div class="modal-overlay hidden" id="deleteModal">
        <div class="modal">
            <div class="modal-header">
                <h2>‚ö†Ô∏è Confirm Delete</h2>
                <button class="modal-close" id="closeDeleteModal">&times;</button>
            </div>
            <div class="modal-body">
                <p style="margin-bottom: 16px;">Are you sure you want to delete this document?</p>
                <p style="color: rgba(255,255,255,0.6); font-size: 13px;">Card ID: <strong id="deleteCardId"></strong></p>
                <p style="color: var(--error-color); font-size: 13px; margin-top: 12px;">‚ö†Ô∏è This action cannot be undone.</p>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" id="cancelDeleteBtn">Cancel</button>
                <button class="btn btn-danger" id="confirmDeleteBtn">Delete</button>
            </div>
        </div>
    </div>

    <!-- Yjs for document sync (ESM via script module) -->
    <script type="module">
        import * as Y from 'https://esm.sh/yjs@13.6.28';
        window.Y = Y;
        window.dispatchEvent(new Event('yjs-loaded'));
    </script>
    
    <script>
        // Yjs reference (set by module script)
        let Y;
        
        // Global state
        let yDoc = null;
        let isModified = false;
        let currentBoardId = null;  // For image URL generation
        let currentTeamId = '0';    // Default team ID
        let isPreviewVisible = false;
        let preservedImageBlocks = new Map(); // blockId -> yBlock (preserved across conversions)
        
        // DOM Elements
        const editorElement = document.getElementById('editor');
        const loadingOverlay = document.getElementById('loadingOverlay');
        const cardIdInput = document.getElementById('cardIdInput');
        const apiBaseInput = document.getElementById('apiBaseInput');
        const loadBtn = document.getElementById('loadBtn');
        const saveBtn = document.getElementById('saveBtn');
        const newDocBtn = document.getElementById('newDocBtn');
        const statusDot = document.getElementById('statusDot');
        const statusText = document.getElementById('statusText');
        const docInfo = document.getElementById('docInfo');
        const toastContainer = document.getElementById('toastContainer');
        const previewPane = document.getElementById('previewPane');
        const previewContent = document.getElementById('previewContent');
        const togglePreviewBtn = document.getElementById('togglePreviewBtn');
        
        // Get CSRF token from Mattermost
        function getCSRFToken() {
            // Try multiple ways to get CSRF token
            if (window.Mattermost?.csrfToken) {
                return window.Mattermost.csrfToken;
            }
            const meta = document.querySelector('meta[name="csrf-token"]');
            if (meta) {
                return meta.getAttribute('content');
            }
            if (window.mm_config?.csrfToken) {
                return window.mm_config.csrfToken;
            }
            // Fallback: try to get from cookies
            const cookies = document.cookie.split(';');
            for (const cookie of cookies) {
                const [name, value] = cookie.trim().split('=');
                if (name === 'MMCSRF') {
                    return value;
                }
            }
            return null;
        }
        
        // Get common headers for API requests
        function getApiHeaders(contentType = null) {
            const headers = {
                'X-Requested-With': 'XMLHttpRequest',
            };
            
            if (contentType) {
                headers['Content-Type'] = contentType;
            }
            
            const csrfToken = getCSRFToken();
            if (csrfToken) {
                headers['X-CSRF-Token'] = csrfToken;
            }
            
            return headers;
        }
        
        // Utility Functions
        function showLoading(show) {
            loadingOverlay.classList.toggle('hidden', !show);
        }
        
        function showToast(message, type = 'success') {
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.textContent = message;
            toastContainer.appendChild(toast);
            
            setTimeout(() => {
                toast.style.opacity = '0';
                toast.style.transition = 'opacity 0.3s ease';
                setTimeout(() => toast.remove(), 300);
            }, 3000);
        }
        
        function updateStatus(status, isError = false) {
            statusDot.className = `status-dot ${isError ? 'error' : (status === 'connected' ? 'connected' : '')}`;
            statusText.textContent = status;
        }
        
        function updateDocInfo(info) {
            docInfo.textContent = info;
        }
        
        // Initialize Yjs Document with BlockSuite structure
        function initEditor(content = '') {
            // Create new Yjs document with BlockSuite structure
            yDoc = new Y.Doc();
            const yBlocks = yDoc.getMap('blocks');
            const yMeta = yDoc.getMap('meta');
            
            // Set initial content as a paragraph block
            if (content) {
                const blockId = 'block-' + Date.now();
                const yBlock = new Y.Map();
                yBlock.set('id', blockId);
                yBlock.set('type', 'affine:paragraph');
                yBlock.set('props', { type: 'text' });
                yBlock.set('text', content);
                yBlocks.set(blockId, yBlock);
                yMeta.set('blockOrder', [blockId]);
            }
            
            // Display in textarea
            editorElement.value = yjsBlocksToText(yDoc);
            
            // Note: For simplicity, textarea edits won't sync back to Yjs blocks
            // In production, you'd use the actual BlockSuite editor
            editorElement.oninput = () => {
                isModified = true;
                saveBtn.disabled = false;
            };
            
            updateStatus('Editor ready', false);
            updateDocInfo('New document (unsaved)');
            saveBtn.disabled = true;
            isModified = false;
        }
        
        // Load document from server (GET /content)
        async function loadFromServer() {
            const cardId = cardIdInput.value.trim();
            const apiBase = apiBaseInput.value.trim();
            
            if (!cardId) {
                showToast('Please enter a Card ID', 'error');
                return;
            }
            
            showLoading(true);
            updateStatus('Loading...');
            
            try {
                const response = await fetch(`${apiBase}/cards/${cardId}/blocksuite/content`, {
                    method: 'GET',
                    credentials: 'include',
                    headers: getApiHeaders(),
                });
                
                if (response.status === 404) {
                    showToast('Document not found. Creating new document.', 'error');
                    initEditor();
                    showLoading(false);
                    updateStatus('Not found', true);
                    return;
                }
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const data = await response.arrayBuffer();
                const snapshot = new Uint8Array(data);
                console.log('Loaded document:', snapshot.byteLength, 'bytes');
                
                // Create new Yjs doc and apply snapshot
                yDoc = new Y.Doc();
                
                if (snapshot.byteLength > 0) {
                    try {
                        Y.applyUpdate(yDoc, snapshot);
                        console.log('Yjs snapshot applied successfully');
                    } catch (e) {
                        console.warn('Failed to apply Yjs snapshot:', e);
                    }
                }
                
                // Save image blocks to global storage
                saveImageBlocksToGlobal();
                
                // Display blocks as text in textarea
                editorElement.value = yjsBlocksToText(yDoc);
                
                // Re-bind input handler
                editorElement.oninput = () => {
                    isModified = true;
                    saveBtn.disabled = false;
                };
                
                updateStatus('connected');
                updateDocInfo(`Card: ${cardId} | Loaded: ${snapshot.byteLength} bytes`);
                showToast(`Document loaded (${snapshot.byteLength} bytes)`);
                
            } catch (error) {
                console.error('Load error:', error);
                updateStatus('Load failed', true);
                showToast(`Failed to load: ${error.message}`, 'error');
            } finally {
                showLoading(false);
            }
        }
        
        // Save document to server (PUT /content)
        async function saveToServer() {
            const cardId = cardIdInput.value.trim();
            const apiBase = apiBaseInput.value.trim();
            
            if (!cardId) {
                showToast('Please enter a Card ID', 'error');
                return;
            }
            
            if (!yDoc) {
                showToast('No document to save', 'error');
                return;
            }
            
            showLoading(true);
            updateStatus('Saving...');
            
            try {
                // Sync textarea changes to Yjs before saving
                const text = editorElement.value;
                textToYjsBlocks(text);
                
                // Export document as Yjs binary snapshot
                const snapshot = Y.encodeStateAsUpdate(yDoc);
                console.log('Yjs snapshot created:', snapshot.byteLength, 'bytes');
                
                const response = await fetch(`${apiBase}/cards/${cardId}/blocksuite/content`, {
                    method: 'PUT',
                    credentials: 'include',
                    headers: getApiHeaders('application/octet-stream'),
                    body: snapshot,
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const result = await response.json();
                console.log('Save result:', result);
                
                isModified = false;
                saveBtn.disabled = true;
                updateStatus('connected');
                updateDocInfo(`Card: ${cardId} | Saved: ${snapshot.byteLength} bytes`);
                showToast(`Document saved successfully (${snapshot.byteLength} bytes)`);
                
            } catch (error) {
                console.error('Save error:', error);
                updateStatus('Save failed', true);
                showToast(`Failed to save: ${error.message}`, 'error');
            } finally {
                showLoading(false);
            }
        }
        
        // Flow Log helper
        const flowLog = document.getElementById('flowLog');
        function logFlow(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString('ko-KR');
            const prefix = type === 'success' ? '‚úÖ' : type === 'error' ? '‚ùå' : type === 'warning' ? '‚ö†Ô∏è' : 'üìç';
            flowLog.innerHTML += `[${timestamp}] ${prefix} ${message}\n`;
            flowLog.scrollTop = flowLog.scrollHeight;
        }
        
        function clearFlowLog() {
            flowLog.innerHTML = '';
        }
        
        // Smart Load: BlockSuite Î¨∏ÏÑú ÏûàÏúºÎ©¥ Î°úÎìú, ÏóÜÏúºÎ©¥ Í∏∞Ï°¥ Î∏îÎ°ù Î≥ÄÌôò
        async function smartLoad() {
            const cardId = cardIdInput.value.trim();
            const apiBase = apiBaseInput.value.trim();
            
            if (!cardId) {
                showToast('Please enter a Card ID', 'error');
                return;
            }
            
            clearFlowLog();
            showLoading(true);
            logFlow(`Starting Smart Load for Card: ${cardId}`);
            
            try {
                // Step 1: Check if BlockSuite document exists
                logFlow('Step 1: Checking if BlockSuite document exists...');
                const infoResponse = await fetch(`${apiBase}/cards/${cardId}/blocksuite/info`, {
                    method: 'GET',
                    credentials: 'include',
                    headers: getApiHeaders(),
                });
                
                if (infoResponse.status === 200) {
                    // Document exists - load it
                    logFlow('BlockSuite document found!', 'success');
                    
                    // Get card info for boardId (needed for image URLs)
                    logFlow('Step 2: Fetching card info for board ID...');
                    const cardResponse = await fetch(`${apiBase}/cards/${cardId}`, {
                        method: 'GET',
                        credentials: 'include',
                        headers: getApiHeaders(),
                    });
                    
                    if (cardResponse.ok) {
                        const card = await cardResponse.json();
                        currentBoardId = card.boardId || card.board_id;
                        logFlow(`Board ID: ${currentBoardId}`, 'success');
                    }
                    
                    logFlow('Step 3: Loading BlockSuite content...');
                    
                    const contentResponse = await fetch(`${apiBase}/cards/${cardId}/blocksuite/content`, {
                        method: 'GET',
                        credentials: 'include',
                        headers: getApiHeaders(),
                    });
                    
                    if (contentResponse.ok) {
                        const data = await contentResponse.arrayBuffer();
                        const snapshot = new Uint8Array(data);
                        
                        // Apply Yjs snapshot
                        yDoc = new Y.Doc();
                        
                        if (snapshot.byteLength > 0) {
                            Y.applyUpdate(yDoc, snapshot);
                        }
                        
                        // Save image blocks to global storage
                        saveImageBlocksToGlobal();
                        
                        // Display blocks as text for preview
                        editorElement.value = yjsBlocksToText(yDoc);
                        bindEditorEvents();
                        
                        // Render preview if visible
                        if (isPreviewVisible) {
                            renderPreview();
                        }
                        
                        logFlow(`Loaded ${snapshot.byteLength} bytes from BlockSuite document`, 'success');
                        updateStatus('connected');
                        updateDocInfo(`Card: ${cardId} | BlockSuite document loaded`);
                        showToast('BlockSuite document loaded!');
                    }
                    
                } else if (infoResponse.status === 404) {
                    // Document doesn't exist - convert blocks
                    logFlow('BlockSuite document NOT found', 'warning');
                    logFlow('Step 2: Fetching card info to get board ID...');
                    
                    // Get card info to find board ID
                    const cardResponse = await fetch(`${apiBase}/cards/${cardId}`, {
                        method: 'GET',
                        credentials: 'include',
                        headers: getApiHeaders(),
                    });
                    
                    if (!cardResponse.ok) {
                        throw new Error(`Card not found: ${cardResponse.status}`);
                    }
                    
                    const card = await cardResponse.json();
                    const boardId = card.boardId || card.board_id;
                    currentBoardId = boardId;  // Store for image URL generation
                    logFlow(`Card found! Board ID: ${boardId}`, 'success');
                    
                    // Step 3: Get existing blocks for this card
                    logFlow('Step 3: Fetching existing content blocks...');
                    const blocksResponse = await fetch(`${apiBase}/boards/${boardId}/blocks?parent_id=${cardId}`, {
                        method: 'GET',
                        credentials: 'include',
                        headers: getApiHeaders(),
                    });
                    
                    let blocks = [];
                    
                    if (blocksResponse.ok) {
                        blocks = await blocksResponse.json();
                        logFlow(`Found ${blocks.length} content blocks`, 'success');
                        logFlow('Step 4: Converting blocks to BlockSuite Yjs format...', 'success');
                    } else {
                        logFlow('No content blocks found, will create empty document', 'warning');
                    }
                    
                    // Step 5: Create Yjs document with BlockSuite structure and save
                    logFlow('Step 5: Creating Yjs document (BlockSuite format) and saving...');
                    
                    yDoc = new Y.Doc();
                    convertLegacyBlocksToYjs(blocks, card, yDoc);
                    
                    // Save image blocks to global storage
                    saveImageBlocksToGlobal();
                    
                    // Display as text in textarea for preview
                    editorElement.value = yjsBlocksToText(yDoc);
                    bindEditorEvents();
                    
                    // Auto-save to server
                    const snapshot = Y.encodeStateAsUpdate(yDoc);
                    const saveResponse = await fetch(`${apiBase}/cards/${cardId}/blocksuite/content`, {
                        method: 'PUT',
                        credentials: 'include',
                        headers: getApiHeaders('application/octet-stream'),
                        body: snapshot,
                    });
                    
                    if (saveResponse.ok) {
                        logFlow(`Auto-saved ${snapshot.byteLength} bytes to server`, 'success');
                        logFlow('‚ú® Migration complete!', 'success');
                        updateStatus('connected');
                        updateDocInfo(`Card: ${cardId} | Migrated from blocks`);
                        showToast('Blocks converted and saved as BlockSuite document!');
                        
                        // Render preview if visible
                        if (isPreviewVisible) {
                            renderPreview();
                        }
                    } else {
                        throw new Error(`Failed to save: ${saveResponse.status}`);
                    }
                    
                } else {
                    throw new Error(`Unexpected response: ${infoResponse.status}`);
                }
                
            } catch (error) {
                console.error('Smart Load error:', error);
                logFlow(`Error: ${error.message}`, 'error');
                updateStatus('Error', true);
                showToast(`Smart Load failed: ${error.message}`, 'error');
            } finally {
                showLoading(false);
            }
        }
        
        // Convert legacy blocks to BlockSuite-compatible Yjs structure
        function convertLegacyBlocksToYjs(blocks, card, ydoc) {
            const yBlocks = ydoc.getMap('blocks');
            const yMeta = ydoc.getMap('meta');
            
            // Sort blocks by contentOrder if available
            const contentOrder = card.fields?.contentOrder || [];
            const sortedBlocks = [...blocks].sort((a, b) => {
                const aIndex = contentOrder.indexOf(a.id);
                const bIndex = contentOrder.indexOf(b.id);
                if (aIndex === -1 && bIndex === -1) return 0;
                if (aIndex === -1) return 1;
                if (bIndex === -1) return -1;
                return aIndex - bIndex;
            });
            
            // Store block order
            const blockOrder = sortedBlocks.map(b => b.id);
            yMeta.set('blockOrder', blockOrder);
            yMeta.set('cardId', card.id);
            yMeta.set('cardTitle', card.title || '');
            
            // Convert each block to Yjs Map
            sortedBlocks.forEach(block => {
                const yBlock = new Y.Map();
                const converted = convertBlockToYjs(block);
                
                Object.entries(converted).forEach(([key, value]) => {
                    yBlock.set(key, value);
                });
                
                yBlocks.set(block.id, yBlock);
            });
            
            logFlow(`Converted ${sortedBlocks.length} blocks to BlockSuite format`, 'success');
        }
        
        // Convert single block to BlockSuite-compatible format
        function convertBlockToYjs(block) {
            const type = block.type;
            const title = block.title || '';
            const fields = block.fields || {};
            
            // Base block structure
            const result = {
                id: block.id,
                originalType: type,
                createdAt: block.createAt || Date.now(),
                updatedAt: block.updateAt || Date.now(),
            };
            
            switch (type) {
                case 'text':
                    result.type = 'affine:paragraph';
                    result.props = { type: 'text' };
                    result.text = title;
                    break;
                case 'h1':
                    result.type = 'affine:paragraph';
                    result.props = { type: 'h1' };
                    result.text = title;
                    break;
                case 'h2':
                    result.type = 'affine:paragraph';
                    result.props = { type: 'h2' };
                    result.text = title;
                    break;
                case 'h3':
                    result.type = 'affine:paragraph';
                    result.props = { type: 'h3' };
                    result.text = title;
                    break;
                case 'checkbox':
                    result.type = 'affine:list';
                    result.props = { 
                        type: 'todo',
                        checked: fields.value || false 
                    };
                    result.text = title;
                    break;
                case 'divider':
                    result.type = 'affine:divider';
                    result.props = {};
                    break;
                case 'quote':
                    result.type = 'affine:paragraph';
                    result.props = { type: 'quote' };
                    result.text = title;
                    break;
                case 'list':
                case 'list-item':
                    result.type = 'affine:list';
                    result.props = { type: 'bulleted' };
                    result.text = title;
                    break;
                case 'numbered-list':
                    result.type = 'affine:list';
                    result.props = { type: 'numbered' };
                    result.text = title;
                    break;
                case 'image':
                    result.type = 'affine:image';
                    result.props = {
                        sourceId: fields.fileId || '',
                        filename: fields.filename || 'image',
                        width: fields.width || 0,
                        height: fields.height || 0,
                    };
                    break;
                case 'video':
                    result.type = 'affine:embed';
                    result.props = {
                        type: 'video',
                        sourceId: fields.fileId || '',
                        filename: fields.filename || 'video',
                    };
                    break;
                case 'attachment':
                    result.type = 'affine:attachment';
                    result.props = {
                        sourceId: fields.fileId || '',
                        filename: fields.filename || 'file',
                        size: fields.size || 0,
                    };
                    break;
                default:
                    result.type = 'affine:paragraph';
                    result.props = { type: 'text' };
                    result.text = title;
            }
            
            return result;
        }
        
        // Convert Yjs blocks to display text (for textarea preview)
        function yjsBlocksToText(ydoc) {
            const yBlocks = ydoc.getMap('blocks');
            const yMeta = ydoc.getMap('meta');
            
            let text = '';
            const cardTitle = yMeta.get('cardTitle');
            if (cardTitle) {
                text += `# ${cardTitle}\n\n`;
            }
            
            const blockOrder = yMeta.get('blockOrder') || [];
            
            blockOrder.forEach(blockId => {
                const yBlock = yBlocks.get(blockId);
                if (yBlock) {
                    const blockText = yBlockToText(yBlock);
                    if (blockText) {
                        text += blockText + '\n';
                    }
                }
            });
            
            // Also include blocks not in order
            yBlocks.forEach((yBlock, blockId) => {
                if (!blockOrder.includes(blockId)) {
                    const blockText = yBlockToText(yBlock);
                    if (blockText) {
                        text += blockText + '\n';
                    }
                }
            });
            
            return text.trim();
        }
        
        function yBlockToText(yBlock) {
            const type = yBlock.get('type') || '';
            const props = yBlock.get('props') || {};
            const blockText = yBlock.get('text') || '';
            
            switch (type) {
                case 'affine:paragraph':
                    const pType = props.type || 'text';
                    if (pType === 'h1') return `# ${blockText}`;
                    if (pType === 'h2') return `## ${blockText}`;
                    if (pType === 'h3') return `### ${blockText}`;
                    if (pType === 'quote') return `> ${blockText}`;
                    return blockText;
                case 'affine:list':
                    const listType = props.type || 'bulleted';
                    if (listType === 'todo') {
                        return props.checked ? `[x] ${blockText}` : `[ ] ${blockText}`;
                    }
                    if (listType === 'numbered') return `1. ${blockText}`;
                    return `- ${blockText}`;
                case 'affine:divider':
                    return '---';
                case 'affine:image':
                    return `[Image: ${props.filename || 'image'}]`;
                case 'affine:embed':
                    return `[Video: ${props.filename || 'video'}]`;
                case 'affine:attachment':
                    return `[Attachment: ${props.filename || 'file'}]`;
                default:
                    return blockText;
            }
        }
        
        // Save image blocks to global storage
        function saveImageBlocksToGlobal() {
            if (!yDoc) return;
            const yBlocks = yDoc.getMap('blocks');
            preservedImageBlocks.clear();
            
            yBlocks.forEach((yBlock, blockId) => {
                const type = yBlock.get('type') || '';
                if (type === 'affine:image' || type === 'affine:embed' || type === 'affine:attachment') {
                    // Deep clone the block
                    const clonedBlock = new Y.Map();
                    yBlock.forEach((value, key) => {
                        if (value instanceof Y.Map) {
                            const clonedValue = new Y.Map();
                            value.forEach((v, k) => clonedValue.set(k, v));
                            clonedBlock.set(key, clonedValue);
                        } else {
                            clonedBlock.set(key, value);
                        }
                    });
                    preservedImageBlocks.set(blockId, clonedBlock);
                    console.log(`[GlobalPreserve] ${type} block: ${blockId}`);
                }
            });
            console.log(`[GlobalPreserve] Total preserved: ${preservedImageBlocks.size}`);
        }
        
        // Convert textarea text back to Yjs blocks
        function textToYjsBlocks(text) {
            if (!yDoc) return;
            
            const yBlocks = yDoc.getMap('blocks');
            const yMeta = yDoc.getMap('meta');
            
            console.log(`[textToYjsBlocks] Starting conversion, current blocks count: ${yBlocks.size}`);
            console.log(`[textToYjsBlocks] Global preserved blocks: ${preservedImageBlocks.size}`);
            
            // First, try to preserve from current Yjs document
            const preservedBlocksByFilename = new Map(); // filename -> {blockId, yBlock}
            const preservedBlocksByType = new Map(); // type -> [{blockId, yBlock, filename}]
            yBlocks.forEach((yBlock, blockId) => {
                const type = yBlock.get('type') || '';
                if (type === 'affine:image' || type === 'affine:embed' || type === 'affine:attachment') {
                    const props = yBlock.get('props') || {};
                    const filename = props.filename || (type === 'affine:image' ? 'image' : type === 'affine:embed' ? 'video' : 'file');
                    preservedBlocksByFilename.set(filename, { blockId, yBlock });
                    
                    // Also store by type for fallback matching
                    if (!preservedBlocksByType.has(type)) {
                        preservedBlocksByType.set(type, []);
                    }
                    preservedBlocksByType.get(type).push({ blockId, yBlock, filename });
                    
                    console.log(`[Preserve] ${type} block: ${blockId}, filename: ${filename}`);
                }
            });
            
            // Also add blocks from global storage (in case current Yjs doc is empty)
            preservedImageBlocks.forEach((yBlock, blockId) => {
                const type = yBlock.get('type') || '';
                if (type === 'affine:image' || type === 'affine:embed' || type === 'affine:attachment') {
                    const props = yBlock.get('props') || {};
                    const filename = props.filename || (type === 'affine:image' ? 'image' : type === 'affine:embed' ? 'video' : 'file');
                    
                    // Only add if not already in preservedBlocksByFilename
                    if (!preservedBlocksByFilename.has(filename)) {
                        preservedBlocksByFilename.set(filename, { blockId, yBlock });
                        console.log(`[GlobalPreserve] Added ${type} block from global: ${blockId}, filename: ${filename}`);
                    }
                    
                    // Also store by type for fallback matching
                    if (!preservedBlocksByType.has(type)) {
                        preservedBlocksByType.set(type, []);
                    }
                    preservedBlocksByType.get(type).push({ blockId, yBlock, filename });
                }
            });
            
            // Store all preserved blocks temporarily
            const allPreservedBlocks = new Map();
            preservedBlocksByFilename.forEach(({ blockId, yBlock }) => {
                allPreservedBlocks.set(blockId, yBlock);
            });
            
            // Clear all blocks
            yBlocks.clear();
            
            if (!text || text.trim() === '') {
                // Restore preserved blocks
                allPreservedBlocks.forEach((yBlock, blockId) => {
                    yBlocks.set(blockId, yBlock);
                });
                const blockOrder = Array.from(allPreservedBlocks.keys());
                yMeta.set('blockOrder', blockOrder);
                return;
            }
            
            const lines = text.split('\n');
            const blockOrder = [];
            let blockIndex = 0;
            const usedPreservedBlocks = new Set();
            
            lines.forEach((line) => {
                if (line.trim() === '') return;
                
                // Handle image/video/attachment placeholders
                if (line.startsWith('[Image:')) {
                    const match = line.match(/\[Image:\s*(.+?)\]/);
                    if (match) {
                        const filename = match[1].trim();
                        console.log(`[Parse] Found [Image: ${filename}] in textarea`);
                        console.log(`[Debug] preservedBlocksByFilename size: ${preservedBlocksByFilename.size}`);
                        console.log(`[Debug] preservedBlocksByType keys:`, Array.from(preservedBlocksByType.keys()));
                        console.log(`[Debug] image blocks count:`, (preservedBlocksByType.get('affine:image') || []).length);
                        
                        let preserved = preservedBlocksByFilename.get(filename);
                        console.log(`[Debug] Exact match found:`, preserved ? preserved.blockId : 'none');
                        
                        // If exact match not found, try to find any unused image block
                        if (!preserved || usedPreservedBlocks.has(preserved.blockId)) {
                            const imageBlocks = preservedBlocksByType.get('affine:image') || [];
                            console.log(`[Debug] Available image blocks:`, imageBlocks.map(b => ({ blockId: b.blockId, filename: b.filename, used: usedPreservedBlocks.has(b.blockId) })));
                            preserved = imageBlocks.find(({ blockId }) => !usedPreservedBlocks.has(blockId));
                            if (preserved) {
                                console.log(`[Fallback] Using first available image block: ${preserved.blockId}`);
                            } else {
                                console.warn(`[Debug] No unused image blocks available`);
                            }
                        }
                        
                        if (preserved && !usedPreservedBlocks.has(preserved.blockId)) {
                            yBlocks.set(preserved.blockId, preserved.yBlock);
                            blockOrder.push(preserved.blockId);
                            usedPreservedBlocks.add(preserved.blockId);
                            console.log(`[Restore] Image block restored: ${preserved.blockId}`);
                        } else {
                            console.warn(`[Warning] No available image block found for filename: ${filename}`);
                            console.warn(`[Debug] preserved:`, preserved);
                            console.warn(`[Debug] usedPreservedBlocks:`, Array.from(usedPreservedBlocks));
                        }
                    }
                    return;
                } else if (line.startsWith('[Video:')) {
                    const match = line.match(/\[Video:\s*(.+?)\]/);
                    if (match) {
                        const filename = match[1].trim();
                        let preserved = preservedBlocksByFilename.get(filename);
                        
                        // If exact match not found, try to find any unused video block
                        if (!preserved || usedPreservedBlocks.has(preserved.blockId)) {
                            const videoBlocks = preservedBlocksByType.get('affine:embed') || [];
                            preserved = videoBlocks.find(({ blockId }) => !usedPreservedBlocks.has(blockId));
                        }
                        
                        if (preserved && !usedPreservedBlocks.has(preserved.blockId)) {
                            yBlocks.set(preserved.blockId, preserved.yBlock);
                            blockOrder.push(preserved.blockId);
                            usedPreservedBlocks.add(preserved.blockId);
                        }
                    }
                    return;
                } else if (line.startsWith('[Attachment:')) {
                    const match = line.match(/\[Attachment:\s*(.+?)\]/);
                    if (match) {
                        const filename = match[1].trim();
                        let preserved = preservedBlocksByFilename.get(filename);
                        
                        // If exact match not found, try to find any unused attachment block
                        if (!preserved || usedPreservedBlocks.has(preserved.blockId)) {
                            const attachmentBlocks = preservedBlocksByType.get('affine:attachment') || [];
                            preserved = attachmentBlocks.find(({ blockId }) => !usedPreservedBlocks.has(blockId));
                        }
                        
                        if (preserved && !usedPreservedBlocks.has(preserved.blockId)) {
                            yBlocks.set(preserved.blockId, preserved.yBlock);
                            blockOrder.push(preserved.blockId);
                            usedPreservedBlocks.add(preserved.blockId);
                        }
                    }
                    return;
                }
                
                const blockId = `block-${blockIndex++}`;
                const yBlock = new Y.Map();
                
                // Parse markdown-style syntax
                if (line.startsWith('# ')) {
                    yBlock.set('id', blockId);
                    yBlock.set('type', 'affine:paragraph');
                    yBlock.set('props', { type: 'h1' });
                    yBlock.set('text', line.substring(2).trim());
                } else if (line.startsWith('## ')) {
                    yBlock.set('id', blockId);
                    yBlock.set('type', 'affine:paragraph');
                    yBlock.set('props', { type: 'h2' });
                    yBlock.set('text', line.substring(3).trim());
                } else if (line.startsWith('### ')) {
                    yBlock.set('id', blockId);
                    yBlock.set('type', 'affine:paragraph');
                    yBlock.set('props', { type: 'h3' });
                    yBlock.set('text', line.substring(4).trim());
                } else if (line.startsWith('> ')) {
                    yBlock.set('id', blockId);
                    yBlock.set('type', 'affine:paragraph');
                    yBlock.set('props', { type: 'quote' });
                    yBlock.set('text', line.substring(2).trim());
                } else if (line.startsWith('[x] ') || line.startsWith('[X] ')) {
                    yBlock.set('id', blockId);
                    yBlock.set('type', 'affine:list');
                    yBlock.set('props', { type: 'todo', checked: true });
                    yBlock.set('text', line.substring(4).trim());
                } else if (line.startsWith('[ ] ')) {
                    yBlock.set('id', blockId);
                    yBlock.set('type', 'affine:list');
                    yBlock.set('props', { type: 'todo', checked: false });
                    yBlock.set('text', line.substring(4).trim());
                } else if (line.match(/^\d+\. /)) {
                    yBlock.set('id', blockId);
                    yBlock.set('type', 'affine:list');
                    yBlock.set('props', { type: 'numbered' });
                    yBlock.set('text', line.replace(/^\d+\. /, '').trim());
                } else if (line.startsWith('- ') || line.startsWith('* ')) {
                    yBlock.set('id', blockId);
                    yBlock.set('type', 'affine:list');
                    yBlock.set('props', { type: 'bulleted' });
                    yBlock.set('text', line.substring(2).trim());
                } else if (line.trim() === '---') {
                    yBlock.set('id', blockId);
                    yBlock.set('type', 'affine:divider');
                    yBlock.set('props', {});
                } else {
                    // Regular paragraph
                    yBlock.set('id', blockId);
                    yBlock.set('type', 'affine:paragraph');
                    yBlock.set('props', { type: 'text' });
                    yBlock.set('text', line.trim());
                }
                
                yBlocks.set(blockId, yBlock);
                blockOrder.push(blockId);
            });
            
            // Add any unused preserved blocks to the end (in case they weren't in textarea)
            allPreservedBlocks.forEach((yBlock, blockId) => {
                if (!usedPreservedBlocks.has(blockId)) {
                    yBlocks.set(blockId, yBlock);
                    blockOrder.push(blockId);
                }
            });
            
            yMeta.set('blockOrder', blockOrder);
        }
        
        // Bind editor input events
        function bindEditorEvents() {
            editorElement.oninput = () => {
                // Don't sync on every input - only mark as modified
                // Actual sync happens when saving
                isModified = true;
                saveBtn.disabled = false;
            };
        }
        
        // Toggle preview panel
        function togglePreview() {
            isPreviewVisible = !isPreviewVisible;
            previewPane.classList.toggle('hidden', !isPreviewVisible);
            togglePreviewBtn.classList.toggle('active', isPreviewVisible);
            
            if (isPreviewVisible && yDoc) {
                renderPreview();
            }
        }
        
        // Render preview with actual images
        async function renderPreview() {
            if (!yDoc) {
                previewContent.innerHTML = '<p style="color: rgba(255,255,255,0.5);">No document loaded</p>';
                return;
            }
            
            const yBlocks = yDoc.getMap('blocks');
            const yMeta = yDoc.getMap('meta');
            const apiBase = apiBaseInput.value.trim();
            
            let html = '';
            
            // Card title
            const cardTitle = yMeta.get('cardTitle');
            if (cardTitle) {
                html += `<h1>${escapeHtml(cardTitle)}</h1>`;
            }
            
            const blockOrder = yMeta.get('blockOrder') || [];
            
            // Render blocks in order
            blockOrder.forEach(blockId => {
                const yBlock = yBlocks.get(blockId);
                if (yBlock) {
                    html += renderBlock(yBlock, apiBase);
                }
            });
            
            // Also include blocks not in order
            yBlocks.forEach((yBlock, blockId) => {
                if (!blockOrder.includes(blockId)) {
                    html += renderBlock(yBlock, apiBase);
                }
            });
            
            previewContent.innerHTML = html || '<p style="color: rgba(255,255,255,0.5);">Empty document</p>';
            
            // Async load all images
            await loadAllImages(apiBase);
        }
        
        // Load all images asynchronously
        async function loadAllImages(apiBase) {
            const imageContainers = previewContent.querySelectorAll('.block-image.loading');
            
            for (const container of imageContainers) {
                const fileId = container.dataset.fileId;
                if (!fileId || !currentBoardId) continue;
                
                try {
                    const imageUrl = `${apiBase}/files/teams/${currentTeamId}/${currentBoardId}/${fileId}`;
                    const response = await fetch(imageUrl, {
                        credentials: 'include',
                        headers: getApiHeaders(),
                    });
                    
                    if (response.ok) {
                        const blob = await response.blob();
                        const blobUrl = URL.createObjectURL(blob);
                        
                        container.classList.remove('loading');
                        container.innerHTML = `
                            <img src="${blobUrl}" alt="image" style="max-width: 100%; height: auto;">
                            <div class="image-caption">üì∑ Image loaded</div>
                        `;
                    } else {
                        container.classList.remove('loading');
                        container.classList.add('error');
                        container.innerHTML = `<span>‚ö†Ô∏è Failed to load (${response.status})</span>`;
                    }
                } catch (error) {
                    console.error('Image load error:', error);
                    container.classList.remove('loading');
                    container.classList.add('error');
                    container.innerHTML = `<span>‚ö†Ô∏è Error: ${error.message}</span>`;
                }
            }
        }
        
        // Render single block as HTML
        function renderBlock(yBlock, apiBase) {
            const type = yBlock.get('type') || '';
            const props = yBlock.get('props') || {};
            const blockText = yBlock.get('text') || '';
            
            switch (type) {
                case 'affine:paragraph':
                    const pType = props.type || 'text';
                    if (pType === 'h1') return `<h1>${escapeHtml(blockText)}</h1>`;
                    if (pType === 'h2') return `<h2>${escapeHtml(blockText)}</h2>`;
                    if (pType === 'h3') return `<h3>${escapeHtml(blockText)}</h3>`;
                    if (pType === 'quote') return `<blockquote class="block-quote">${escapeHtml(blockText)}</blockquote>`;
                    return `<p>${escapeHtml(blockText)}</p>`;
                    
                case 'affine:list':
                    const listType = props.type || 'bulleted';
                    if (listType === 'todo') {
                        const checked = props.checked ? 'checked' : '';
                        const checkedClass = props.checked ? 'checked' : '';
                        return `<div class="block-todo ${checkedClass}">
                            <input type="checkbox" ${checked} disabled>
                            <span>${escapeHtml(blockText)}</span>
                        </div>`;
                    }
                    if (listType === 'numbered') return `<div class="block-list">1. ${escapeHtml(blockText)}</div>`;
                    return `<div class="block-list">‚Ä¢ ${escapeHtml(blockText)}</div>`;
                    
                case 'affine:divider':
                    return '<hr class="block-divider">';
                    
                case 'affine:image':
                    const imageId = props.sourceId;
                    const imageFilename = props.filename || 'image';
                    const blockId = yBlock.get('id') || `img-${Date.now()}`;
                    if (imageId && currentBoardId) {
                        // Create placeholder with unique ID for async loading
                        return `<div class="block-image loading" id="img-${blockId}" data-file-id="${imageId}">
                            <span>‚è≥ Loading: ${escapeHtml(imageFilename)}...</span>
                        </div>`;
                    }
                    return `<div class="block-image error"><span>‚ö†Ô∏è Image: ${escapeHtml(imageFilename)} (no source)</span></div>`;
                    
                case 'affine:embed':
                    const videoId = props.sourceId;
                    const videoFilename = props.filename || 'video';
                    if (videoId && currentBoardId) {
                        const videoUrl = `${apiBase}/files/teams/${currentTeamId}/${currentBoardId}/${videoId}`;
                        return `<div class="block-video">
                            <video controls>
                                <source src="${videoUrl}" type="video/mp4">
                                Your browser does not support the video tag.
                            </video>
                        </div>`;
                    }
                    return `<div class="block-video"><p>üé¨ Video: ${escapeHtml(videoFilename)}</p></div>`;
                    
                case 'affine:attachment':
                    const fileId = props.sourceId;
                    const filename = props.filename || 'file';
                    const fileSize = props.size || 0;
                    if (fileId && currentBoardId) {
                        const fileUrl = `${apiBase}/files/teams/${currentTeamId}/${currentBoardId}/${fileId}`;
                        const sizeStr = formatFileSize(fileSize);
                        return `<a href="${fileUrl}" class="block-attachment" target="_blank" download>
                            <span class="file-icon">üìé</span>
                            <div class="file-info">
                                <div class="file-name">${escapeHtml(filename)}</div>
                                <div class="file-size">${sizeStr}</div>
                            </div>
                        </a>`;
                    }
                    return `<div class="block-attachment"><span class="file-icon">üìé</span><span>${escapeHtml(filename)}</span></div>`;
                    
                default:
                    return blockText ? `<p>${escapeHtml(blockText)}</p>` : '';
            }
        }
        
        // Escape HTML special characters
        function escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // Format file size
        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }
        
        // Get document info from server
        async function getDocInfo() {
            const cardId = cardIdInput.value.trim();
            const apiBase = apiBaseInput.value.trim();
            
            if (!cardId) {
                showToast('Please enter a Card ID', 'error');
                return;
            }
            
            showLoading(true);
            updateStatus('Fetching info...');
            
            try {
                const response = await fetch(`${apiBase}/cards/${cardId}/blocksuite/info`, {
                    method: 'GET',
                    credentials: 'include',
                    headers: getApiHeaders(),
                });
                
                if (response.status === 404) {
                    showToast('Document not found', 'error');
                    showLoading(false);
                    updateStatus('Not found', true);
                    return;
                }
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const info = await response.json();
                console.log('Document info:', info);
                
                // Display info in modal
                displayInfoModal(info);
                
                updateStatus('connected');
                showToast('Document info loaded');
                
            } catch (error) {
                console.error('Info error:', error);
                updateStatus('Info failed', true);
                showToast(`Failed to get info: ${error.message}`, 'error');
            } finally {
                showLoading(false);
            }
        }
        
        // Display info modal
        function displayInfoModal(info) {
            const infoGrid = document.getElementById('infoGrid');
            const infoModal = document.getElementById('infoModal');
            
            // Format dates
            const formatDate = (timestamp) => {
                if (!timestamp) return 'N/A';
                return new Date(timestamp).toLocaleString('ko-KR');
            };
            
            // Build info grid
            infoGrid.innerHTML = `
                <span class="info-label">Document ID</span>
                <span class="info-value">${info.doc_id || info.docId || 'N/A'}</span>
                
                <span class="info-label">Card ID</span>
                <span class="info-value">${info.card_id || info.cardId || 'N/A'}</span>
                
                <span class="info-label">Board ID</span>
                <span class="info-value">${info.board_id || info.boardId || 'N/A'}</span>
                
                <span class="info-label">Snapshot Size</span>
                <span class="info-value">${info.snapshot_size || info.snapshotSize || 0} bytes</span>
                
                <span class="info-label">Created At</span>
                <span class="info-value">${formatDate(info.created_at || info.createdAt)}</span>
                
                <span class="info-label">Updated At</span>
                <span class="info-value">${formatDate(info.updated_at || info.updatedAt)}</span>
                
                <span class="info-label">Created By</span>
                <span class="info-value">${info.created_by || info.createdBy || 'N/A'}</span>
                
                <span class="info-label">Updated By</span>
                <span class="info-value">${info.updated_by || info.updatedBy || 'N/A'}</span>
            `;
            
            infoModal.classList.remove('hidden');
        }
        
        // Delete document from server
        async function deleteFromServer() {
            const cardId = cardIdInput.value.trim();
            const apiBase = apiBaseInput.value.trim();
            
            showLoading(true);
            updateStatus('Deleting...');
            
            try {
                const response = await fetch(`${apiBase}/cards/${cardId}/blocksuite`, {
                    method: 'DELETE',
                    credentials: 'include',
                    headers: getApiHeaders(),
                });
                
                if (response.status === 404) {
                    showToast('Document not found', 'error');
                    showLoading(false);
                    updateStatus('Not found', true);
                    return;
                }
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                console.log('Document deleted');
                
                // Reset editor
                initEditor();
                
                updateStatus('Deleted');
                updateDocInfo('Document deleted');
                showToast('Document deleted successfully');
                
            } catch (error) {
                console.error('Delete error:', error);
                updateStatus('Delete failed', true);
                showToast(`Failed to delete: ${error.message}`, 'error');
            } finally {
                showLoading(false);
                document.getElementById('deleteModal').classList.add('hidden');
            }
        }
        
        // Show delete confirmation modal
        function showDeleteConfirm() {
            const cardId = cardIdInput.value.trim();
            
            if (!cardId) {
                showToast('Please enter a Card ID', 'error');
                return;
            }
            
            document.getElementById('deleteCardId').textContent = cardId;
            document.getElementById('deleteModal').classList.remove('hidden');
        }
        
        // DOM Elements for new buttons
        const saveBtn2 = document.getElementById('saveBtn2');
        const infoBtn = document.getElementById('infoBtn');
        const deleteBtn = document.getElementById('deleteBtn');
        const smartLoadBtn = document.getElementById('smartLoadBtn');
        const infoModal = document.getElementById('infoModal');
        const deleteModal = document.getElementById('deleteModal');
        
        // Event Listeners
        smartLoadBtn.addEventListener('click', smartLoad);
        loadBtn.addEventListener('click', loadFromServer);
        saveBtn.addEventListener('click', saveToServer);
        saveBtn2.addEventListener('click', saveToServer);
        infoBtn.addEventListener('click', getDocInfo);
        deleteBtn.addEventListener('click', showDeleteConfirm);
        togglePreviewBtn.addEventListener('click', togglePreview);
        newDocBtn.addEventListener('click', () => {
            initEditor();
            showToast('New document created');
        });
        
        // Modal close handlers
        document.getElementById('closeInfoModal').addEventListener('click', () => {
            infoModal.classList.add('hidden');
        });
        document.getElementById('closeInfoModalBtn').addEventListener('click', () => {
            infoModal.classList.add('hidden');
        });
        document.getElementById('closeDeleteModal').addEventListener('click', () => {
            deleteModal.classList.add('hidden');
        });
        document.getElementById('cancelDeleteBtn').addEventListener('click', () => {
            deleteModal.classList.add('hidden');
        });
        document.getElementById('confirmDeleteBtn').addEventListener('click', deleteFromServer);
        
        // Close modals on overlay click
        infoModal.addEventListener('click', (e) => {
            if (e.target === infoModal) infoModal.classList.add('hidden');
        });
        deleteModal.addEventListener('click', (e) => {
            if (e.target === deleteModal) deleteModal.classList.add('hidden');
        });
        
        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if ((e.metaKey || e.ctrlKey) && e.key === 's') {
                e.preventDefault();
                if (!saveBtn.disabled) {
                    saveToServer();
                }
            }
            // ESC to close modals
            if (e.key === 'Escape') {
                infoModal.classList.add('hidden');
                deleteModal.classList.add('hidden');
            }
        });
        
        // Initialize on load - wait for Yjs to be loaded
        function startApp() {
            if (window.Y) {
                Y = window.Y;
                initEditor();
                console.log('Yjs Editor initialized with all 4 API endpoints');
            } else {
                window.addEventListener('yjs-loaded', () => {
                    Y = window.Y;
                    initEditor();
                    console.log('Yjs Editor initialized with all 4 API endpoints');
                });
            }
        }
        
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', startApp);
        } else {
            startApp();
        }
    </script>
</body>
</html>

